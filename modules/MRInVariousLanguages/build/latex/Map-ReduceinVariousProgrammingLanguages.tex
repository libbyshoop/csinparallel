% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Map-Reduce in Various Programming Languages}
\date{July 26, 2012}
\release{}
\author{CSInParallel Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Context of Map-Reduce Computing}
\label{Context/Context:context-of-map-reduce-computing}\label{Context/Context::doc}\label{Context/Context:map-reduce-in-various-programming-languages}\begin{itemize}
\item {} 
The use of LISP's map and reduce functions to solve computational problems probably dates from the 1960s -- very early in the history of programming languages

\item {} 
In 2004, Google published their adaptation of the map-reduce strategy for data-intensive scalable computing (DISC) on large clusters. Their implementation, called \textbf{MapReduce}, incorporates features automatically to split up enormous (e.g., multiple \emph{petabytes}) data sets, schedule the mapper and reducer processes, arrange for those processes always to operate on local data for performance efficiency, and recover from faults such as computers or racks crashing.

\item {} 
MapReduce, together with the page rank algorithm, gave Google the competitive combination it needed to become the most popular search engine (approximately 2/3 of the market at present). Google proceeded to apply map-reduce techniques to everything from ad placement to maps and document services.

\item {} 
Google's MapReduce is proprietary software. But Yahoo! created the Hadoop implementation of this map-reduce strategy for clusters as an Apache Software Foundation open-source project. Consequently, Hadoop is used not only at Yahoo!, but at numerous other web service companies, and is available for use at colleges and universities.

\item {} 
\emph{Future systems:} (1) Strategies such as map-reduce that enable programmers to provide relatively simple code segments and reuse code for synchronization, fault tolerance, etc., are a target for forthcoming systems (\emph{View from Berkeley}, 2006). (2) Future systems are likely to consist of multiple heterogeneous cores, programmed using functional programming techniques (Michael Wrinn, Intel, keynote speech at SIGCSE 2010).

\end{itemize}


\chapter{Example: WebMapReduce using Scheme language}
\label{SchemeLanguage/SchemeLanguage::doc}\label{SchemeLanguage/SchemeLanguage:example-webmapreduce-using-scheme-language}\begin{itemize}
\item {} 
\textbf{WebMapReduce (WMR)} is a strategically simplified interface for performing map-reduce computing developed by students from St. Olaf College.  While initially supporting Scheme, the platform currently supports several high-level languages, including Python, C++, and Java.

\item {} 
Wmr\_scm.pdf includes specs for the functions provided in this Scheme WMR interface. \code{download Wmr\_scm.pdf}

\item {} 
This implementation of the Scheme interface for entering mappers and reducers uses an iterator for providing values in a reducer. Each call of a reducer receives all the key-value pairs for a particular key, and the two arguments for that reducer are that key and an iterator for obtaining the values.
\begin{quote}

\textbf{Iterator} - an (object-oriented programming) object that enables a programmer to obtain each value in a collection as a sequence of values, encapsulating the internal representation of that collection.  We may visualize an iterator as a ``dispenser'' of values, providing one value at a time until all are exhausted.
\end{quote}

\item {} 
Iterators are used to provide reducer values because when there are very many key-value pairs, the total size of the collection of values may exceed the size of main memory.

\item {} 
As the spec indicates, the second argument of a reducer is a \code{WmrIterator} object (we'll call it \code{iter}), and that object \code{iter} has two methods:
\begin{itemize}
\item {} 
The call (\code{iter 'has-next}) returns true if a next element exists, false otherwise.

\item {} 
The call (\code{iter 'get-next}) delivers the next element from the iterator, and advances that iterator (so a next call to the iterator will return a fresh value, if available); this call returns false if there is no next value.

\end{itemize}

\end{itemize}


\chapter{WebMapReduce in various languages}
\label{VariousLanguages/VariousLanguages::doc}\label{VariousLanguages/VariousLanguages:webmapreduce-in-various-languages}
The following subsections include the word count mapper and reducer implementations for WMR in several languages:


\section{Scheme}
\label{VariousLanguages/VariousLanguages:scheme}
Word count for WMR in Scheme language (spec is found on \code{Wmr\_scm.pdf})


\subsection{mapper}
\label{VariousLanguages/VariousLanguages:mapper}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{define }\PYG{n+nv}{helper}
  \PYG{p}{(}\PYG{k}{lambda }\PYG{p}{(}\PYG{n+nf}{lis}\PYG{p}{)} \PYG{c+c1}{; a list of strings}
    \PYG{p}{(}\PYG{k}{cond }
      \PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{null? }\PYG{n+nv}{lis}\PYG{p}{)} \PYG{n+no}{\#t}\PYG{p}{)}
      \PYG{c+c1}{;; at least one element in lis}
      \PYG{p}{(}\PYG{k}{else }\PYG{p}{(}\PYG{n+nf}{wmr-emit} \PYG{p}{(}\PYG{n+nb}{car }\PYG{n+nv}{lis}\PYG{p}{)} \PYG{l+s}{"1"}\PYG{p}{)}
            \PYG{p}{(}\PYG{n+nf}{helper} \PYG{p}{(}\PYG{n+nb}{cdr }\PYG{n+nv}{lis}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{k}{define }\PYG{n+nv}{mapper}
  \PYG{p}{(}\PYG{k}{lambda }\PYG{p}{(}\PYG{n+nf}{key} \PYG{n+nv}{value}\PYG{p}{)}
    \PYG{p}{(}\PYG{n+nf}{helper} \PYG{p}{(}\PYG{n+nf}{wmr-split} \PYG{n+nv}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsection{reducer}
\label{VariousLanguages/VariousLanguages:reducer}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k}{define }\PYG{n+nv}{loop}
  \PYG{p}{(}\PYG{k}{lambda }\PYG{p}{(}\PYG{n+nf}{key} \PYG{n+nv}{iter} \PYG{n+nv}{ct}\PYG{p}{)} \PYG{c+c1}{; a key,value iterator in its current state, and}
                        \PYG{c+c1}{; subtotal so far}
    \PYG{p}{(}\PYG{k}{cond }
      \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{iter} \PYG{l+s+ss}{'has-next}\PYG{p}{)} 
       \PYG{p}{(}\PYG{n+nf}{loop} \PYG{n+nv}{key} \PYG{n+nv}{iter} \PYG{p}{(}\PYG{n+nb}{+ }\PYG{n+nv}{ct} \PYG{p}{(}\PYG{n+nb}{string-\textgreater{}number }\PYG{p}{(}\PYG{n+nf}{iter} \PYG{l+s+ss}{'get-next}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
      \PYG{c+c1}{;; assert -- no more input values to add}
      \PYG{p}{(}\PYG{k}{else }\PYG{p}{(}\PYG{n+nf}{wmr-emit} \PYG{n+nv}{key} \PYG{p}{(}\PYG{n+nb}{number-\textgreater{}string }\PYG{n+nv}{ct}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{p}{(}\PYG{k}{define }\PYG{n+nv}{reducer}
  \PYG{p}{(}\PYG{k}{lambda }\PYG{p}{(}\PYG{n+nf}{key} \PYG{n+nv}{iter}\PYG{p}{)}
    \PYG{p}{(}\PYG{n+nf}{loop} \PYG{n+nv}{key} \PYG{n+nv}{iter} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
For this WMR interface for Scheme (see spec for details):
\begin{itemize}
\item {} 
As indicated before, the mapper and reducer in this Scheme interface are functions.

\item {} 
String manipulation functions are primitive in Scheme, so a library function \code{split} is provided for this interface that allows one to specify delimiters by a regular-expression pattern. Type conversion is provided in Scheme through convenient (though long-named) functions \code{number-\textgreater{}string} and \code{string-\textgreater{}number}.

\item {} 
We use Scheme-style objects as implemented at St. Olaf for the iterator for a reducer, as described above.

\end{itemize}
\end{notice}


\section{C++}
\label{VariousLanguages/VariousLanguages:c}
Word count for WMR in C++ language (C++ style iterators, spec is found on \code{Wmr\_cpp.pdf})


\subsection{mapper}
\label{VariousLanguages/VariousLanguages:id1}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Mapper}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{mapper}\PYG{p}{(}\PYG{n}{string} \PYG{n}{key}\PYG{p}{,} \PYG{n}{string} \PYG{n}{value}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char} \PYG{n}{delim} \PYG{o}{=} \PYG{l+s+sc}{' '}\PYG{p}{;}
        \PYG{n}{vector} \PYG{n}{splits} \PYG{o}{=} \PYG{n}{Wmr}\PYG{o}{:}\PYG{o}{:}\PYG{n}{split}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{delim}\PYG{p}{)}\PYG{p}{;}
        
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\textless{}} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Wmr}\PYG{o}{:}\PYG{o}{:}\PYG{n}{emit}\PYG{p}{(}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{1}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}


\subsection{reducer}
\label{VariousLanguages/VariousLanguages:id2}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Reducer}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{reducer}\PYG{p}{(}\PYG{n}{string} \PYG{n}{key}\PYG{p}{,} \PYG{n}{WmrIterator} \PYG{n}{iter}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{long} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{n}{iter} \PYG{o}{!}\PYG{o}{=} \PYG{n}{WmrIterator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Wmr}\PYG{o}{:}\PYG{o}{:}\PYG{n}{strToLong}\PYG{p}{(}\PYG{o}{*}\PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        
        \PYG{n}{Wmr}\PYG{o}{:}\PYG{o}{:}\PYG{n}{emit}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{Wmr}\PYG{o}{:}\PYG{o}{:}\PYG{n}{longToStr}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

\begin{notice}{note}{Note:}\begin{quote}

for this WMR interface for C++ (see spec for details):
\end{quote}
\begin{itemize}
\item {} 
The \code{mapper} and \code{reducer} are methods of classes Mapper and Reducer, respectively.

\item {} 
Strings are split using the method \code{Wmr::split()} of a (predefined) library class \code{Wmr.} Rather than splitting on arbitrary regular expressions, the (required) second argument of \code{Wmr::split()} is a string of characters, any one of which counts as a delimiter. Type conversion between numbers and strings is not convenient in C++, so helper methods are provided.

\item {} 
C++-style iterators are used in the reducer method. In this style of iterator, \code{operator*} delivers the current value, \code{operator++} is used to advance to the next value, and the end of an iterator is detected by comparing that iterator for equality with the special iterator value \code{WmrIterator::end}.

\end{itemize}
\end{notice}


\section{Java}
\label{VariousLanguages/VariousLanguages:java}
Word count for WMR in Java language (Java style iterators, spec is found on \code{Wmr\_java.pdf})


\subsection{mapper}
\label{VariousLanguages/VariousLanguages:id3}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Mapper for word count */}

\PYG{k+kd}{class} \PYG{n+nc}{Mapper} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{mapper}\PYG{o}{(}\PYG{n}{String} \PYG{n}{key}\PYG{o}{,} \PYG{n}{String} \PYG{n}{value}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{String} \PYG{n}{words}\PYG{o}{[}\PYG{o}{]} \PYG{o}{=} \PYG{n}{key}\PYG{o}{.}\PYG{n+na}{split}\PYG{o}{(}\PYG{l+s}{" "}\PYG{o}{)}\PYG{o}{;}
    \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
    \PYG{k}{for} \PYG{o}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}  \PYG{n}{i} \PYG{o}{\textless{}} \PYG{n}{words}\PYG{o}{.}\PYG{n+na}{length}\PYG{o}{;}  \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{o}{)}
      \PYG{n}{Wmr}\PYG{o}{.}\PYG{n+na}{emit}\PYG{o}{(}\PYG{n}{words}\PYG{o}{[}\PYG{n}{i}\PYG{o}{]}\PYG{o}{,} \PYG{l+s}{"1"}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{reducer}
\label{VariousLanguages/VariousLanguages:id4}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Reducer for word count */}

\PYG{k+kd}{class} \PYG{n+nc}{Reducer} \PYG{o}{\PYGZob{}}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{reducer}\PYG{o}{(}\PYG{n}{String} \PYG{n}{key}\PYG{o}{,} \PYG{n}{WmrIterator} \PYG{n}{iter}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
    \PYG{k}{while} \PYG{o}{(}\PYG{n}{iter}\PYG{o}{.}\PYG{n+na}{hasNext}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)} \PYG{o}{\PYGZob{}}
      \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{parseInt}\PYG{o}{(}\PYG{n}{iter}\PYG{o}{.}\PYG{n+na}{next}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
    \PYG{n}{Wmr}\PYG{o}{.}\PYG{n+na}{emit}\PYG{o}{(}\PYG{n}{key}\PYG{o}{,} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{valueOf}\PYG{o}{(}\PYG{n}{sum}\PYG{o}{)}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

\PYG{o}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
for this WMR interface for Java (see spec for details):
\begin{itemize}
\item {} 
The mapper and reducer are again methods of classes \code{Mapper} and \code{Reducer}, respectively, as for C++.

\item {} 
Java provides useful string manipulation methods. Type conversion is provided in the Java libraries, but is inconvenient.

\item {} 
Java style iterators are used for the reducer. These have methods \code{hasNext()} which returns \code{false} when no new values exist in an iterator, and \code{next()} which returns the next unseen value and advances that iterator.

\end{itemize}
\end{notice}


\section{Python}
\label{VariousLanguages/VariousLanguages:python}
Word count for WMR in Python3 language (Python3 style iterators, spec is found on \code{Wmr\_jpy3.pdf})


\subsection{mapper}
\label{VariousLanguages/VariousLanguages:id5}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mapper}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words}\PYG{o}{=}\PYG{n}{key}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{:}
        \PYG{n}{Wmr}\PYG{o}{.}\PYG{n}{emit}\PYG{p}{(}\PYG{n}{word}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{1}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\subsection{reducer}
\label{VariousLanguages/VariousLanguages:id6}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reducer}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n+nb}{iter}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n+nb}{iter}\PYG{p}{:}
        \PYG{n+nb}{sum} \PYG{o}{=} \PYG{n+nb}{sum} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
    \PYG{n}{Wmr}\PYG{o}{.}\PYG{n}{emit}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
Notes for this WMR interface for Python3 (see spec for details):
\begin{itemize}
\item {} 
The mapper and reducer for this interface are functions, as was the case for Scheme.

\item {} 
Python provides many useful string manipulation methods for string objects, as well as convenient type conversion functions \code{int()} and \code{str()}.

\item {} 
The reducer uses a Python-style iterator, which may be used conveniently in a \code{for} loop construct.

\end{itemize}
\end{notice}


\section{Comparison}
\label{VariousLanguages/VariousLanguages:comparison}
For comparison, here is an implementation of word count mapper and reducer for Java using Hadoop map-reduce directly, without using WMR.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Java WordCount for Hadoop}
\PYG{c+c1}{// Based on Hadoop documentation}

\PYG{k+kn}{package} \PYG{n}{wc}\PYG{o}{;}

\PYG{k+kn}{import} \PYG{n+nn}{java.io.IOException}\PYG{o}{;}
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}

\PYG{k+kn}{import} \PYG{n+nn}{org.apache.hadoop.fs.Path}\PYG{o}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org.apache.hadoop.conf.*}\PYG{o}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org.apache.hadoop.io.*}\PYG{o}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org.apache.hadoop.mapred.*}\PYG{o}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org.apache.hadoop.util.*}\PYG{o}{;}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{WordCount} \PYG{o}{\PYGZob{}}

  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kt}{void} \PYG{n+nf}{main}\PYG{o}{(}\PYG{n}{String}\PYG{o}{[}\PYG{o}{]} \PYG{n}{args}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
    \PYG{n}{JobConf} \PYG{n}{conf} \PYG{o}{=} \PYG{k}{new} \PYG{n}{JobConf}\PYG{o}{(}\PYG{n}{WordCount}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setJobName}\PYG{o}{(}\PYG{l+s}{"WordCount"}\PYG{o}{)}\PYG{o}{;}
    
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setOutputKeyClass}\PYG{o}{(}\PYG{n}{Text}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setOutputValueClass}\PYG{o}{(}\PYG{n}{IntWritable}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}

    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setMapperClass}\PYG{o}{(}\PYG{n}{Map}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setCombinerClass}\PYG{o}{(}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setReducerClass}\PYG{o}{(}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}

    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setInputFormat}\PYG{o}{(}\PYG{n}{TextInputFormat}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{conf}\PYG{o}{.}\PYG{n+na}{setOutputFormat}\PYG{o}{(}\PYG{n}{TextOutputFormat}\PYG{o}{.}\PYG{n+na}{class}\PYG{o}{)}\PYG{o}{;}

    \PYG{n}{FileInputFormat}\PYG{o}{.}\PYG{n+na}{setInputPaths}\PYG{o}{(}\PYG{n}{conf}\PYG{o}{,} \PYG{k}{new} \PYG{n}{Path}\PYG{o}{(}\PYG{n}{args}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{]}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{n}{FileOutputFormat}\PYG{o}{.}\PYG{n+na}{setOutputPath}\PYG{o}{(}\PYG{n}{conf}\PYG{o}{,} \PYG{k}{new} \PYG{n}{Path}\PYG{o}{(}\PYG{n}{args}\PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{]}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    
    \PYG{n}{JobClient}\PYG{o}{.}\PYG{n+na}{runJob}\PYG{o}{(}\PYG{n}{conf}\PYG{o}{)}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kd}{class} \PYG{n+nc}{Map} \PYG{k+kd}{extends} \PYG{n}{MapReduceBase} 
      \PYG{k+kd}{implements} \PYG{n}{Mapper} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{private} \PYG{k+kd}{final} \PYG{k+kd}{static} \PYG{n}{IntWritable} \PYG{n}{one} \PYG{o}{=} \PYG{k}{new} \PYG{n}{IntWritable}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{;}
    \PYG{k+kd}{private} \PYG{n}{Text} \PYG{n}{word} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Text}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}

    \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{map}\PYG{o}{(}\PYG{n}{LongWritable} \PYG{n}{key}\PYG{o}{,} \PYG{n}{Text} \PYG{n}{value}\PYG{o}{,} 
                    \PYG{n}{OutputCollector} \PYG{n}{output}\PYG{o}{,} 
                    \PYG{n}{Reporter} \PYG{n}{reporter}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{IOException} \PYG{o}{\PYGZob{}}
      \PYG{n}{String} \PYG{n}{line} \PYG{o}{=} \PYG{n}{value}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
      \PYG{n}{StringTokenizer} \PYG{n}{tokenizer} \PYG{o}{=} \PYG{k}{new} \PYG{n}{StringTokenizer}\PYG{o}{(}\PYG{n}{line}\PYG{o}{)}\PYG{o}{;}
      \PYG{k}{while} \PYG{o}{(}\PYG{n}{tokenizer}\PYG{o}{.}\PYG{n+na}{hasMoreTokens}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{word}\PYG{o}{.}\PYG{n+na}{set}\PYG{o}{(}\PYG{n}{tokenizer}\PYG{o}{.}\PYG{n+na}{nextToken}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
        \PYG{n}{output}\PYG{o}{.}\PYG{n+na}{collect}\PYG{o}{(}\PYG{n}{word}\PYG{o}{,} \PYG{n}{one}\PYG{o}{)}\PYG{o}{;}
      \PYG{o}{\PYGZcb{}}
    \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}}

  \PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{k+kd}{class} \PYG{n+nc}{Reduce} \PYG{k+kd}{extends} \PYG{n}{MapReduceBase} 
      \PYG{k+kd}{implements} \PYG{n}{Reducer} \PYG{o}{\PYGZob{}}
    \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{reduce}\PYG{o}{(}\PYG{n}{Text} \PYG{n}{key}\PYG{o}{,} \PYG{n}{Iterator} \PYG{n}{values}\PYG{o}{,} \PYG{n}{OutputCollector} \PYG{n}{output}\PYG{o}{,} \PYG{n}{Reporter} \PYG{n}{reporter}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{IOException} \PYG{o}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
      \PYG{k}{while} \PYG{o}{(}\PYG{n}{values}\PYG{o}{.}\PYG{n+na}{hasNext}\PYG{o}{(}\PYG{o}{)}\PYG{o}{)} \PYG{o}{\PYGZob{}}
        \PYG{n}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{values}\PYG{o}{.}\PYG{n+na}{next}\PYG{o}{(}\PYG{o}{)}\PYG{o}{.}\PYG{n+na}{get}\PYG{o}{(}\PYG{o}{)}\PYG{o}{;}
      \PYG{o}{\PYGZcb{}}

      \PYG{n}{output}\PYG{o}{.}\PYG{n+na}{collect}\PYG{o}{(}\PYG{n}{key}\PYG{o}{,} \PYG{k}{new} \PYG{n}{IntWritable}\PYG{o}{(}\PYG{n}{sum}\PYG{o}{)}\PYG{o}{)}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}}

\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\chapter{Accessing concurrency and parallelism within a programming language}
\label{AccessingConcurrency/AccessingConcurrency::doc}\label{AccessingConcurrency/AccessingConcurrency:accessing-concurrency-and-parallelism-within-a-programming-language}

\section{Features that are part of a programming language}
\label{AccessingConcurrency/AccessingConcurrency:features-that-are-part-of-a-programming-language}\begin{itemize}
\item {} 
\textbf{Java} \code{synchronized}: a method or a segment of code within a method can be marked as \code{synchronized}, meaning that no two threads of execution may execute in synchronized sections for the same object at the same time.

\item {} 
\textbf{Ada} (developed for DOD applications in 1980s): threads (``concurrent tasks''), which may be created dynamically; ``rendezvous'' (cf. remote procedure call) with synchronized communication.

\item {} 
\textbf{Erlang}: The language consists of (functional programming) \emph{sequential} constructs plus additional \emph{concurrent} constructs for carrying out sequential code in parallel. No threads, just processes â€“ a design decision to allow for easier fault tolerance, because shared resources such as memory are very difficult to manage correctly in the presence of faults.

\end{itemize}


\section{Libraries}
\label{AccessingConcurrency/AccessingConcurrency:libraries}\begin{itemize}
\item {} 
\textbf{MPI (Message Passing Interface)}: Library allowing for send, receive, and other communication calls for both \emph{point-to-point} and \emph{collective} communication in a distributed system. Supports a notion of ``communicator groups'' of processes.

\item {} 
\textbf{Java} \code{Thread} \textbf{class}; \code{java.util.concurrent}: These are standard packages in the Java language. The \code{Thread} class may be subclassed to provide a (sequential) \code{run()} method for carrying out specified code when that thread object is started. The package \code{java.util.concurrent} provides programming interfaces and classes for concurrency-safe data structures, thread management/reuse and scheduling, synchronization primitives such as semaphores, etc.

\end{itemize}


\section{Other approaches}
\label{AccessingConcurrency/AccessingConcurrency:other-approaches}\begin{itemize}
\item {} 
\textbf{Operating system calls}: For example, Linux provides \code{fork()} for creating new processes, \code{socket()} and related system calls for creating communication lines between processes that may be on separate machines, \code{read()} and \code{write()} for sending and receiving along socket connections, \code{select()} for synchronizing communication, and various thread packages exist for Linux.

\item {} 
\textbf{OpenMP C/C++ pragmas}: A convenient approach for incrementally adding synchronization in a shared-memory multiprocessor (such as a multicore system), in which one adds preprocessor \code{pragmas} to request parallelization of a \code{for} loop, creation of threads, etc.

\item {} 
\textbf{CUDA programming of a GPGPU}: Modern video controllers are highly parallel devices designed for highly parallel, very fast linear algebra computations that feed a pipeline for adding further graphics features (such as texturing). NVIDIA and other manufacturers now provide a programming interface enabling a programmer to make general-purpose computations with that specialized hardware---``General Purpose Graphics Processing Unit (GPGPU)''. NVIDIA's CUDA language provides a library for C and C++ programs for the CPU that interact with separate ``kernel'' programs written for the GPU in order to perform such GPGPU computations.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
